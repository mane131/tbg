<!--
3D Block Multiplayer Game
Files included in this single document:
  1) client: index.html (open in browser; connects to the server at the address you choose)
  2) server: server.js (Node.js + Express + Socket.io)

How it works (quick):
 - Player opens index.html, enters a username and lobby name and clicks Join.
 - The client connects to the Node server via socket.io and joins the chosen lobby (room).
 - The client sends periodic position/rotation updates and chat messages to the server.
 - The server relays those updates to other players in the same lobby.

Notes & next steps:
 - This is a minimal, self-contained prototype.
 - For production you'd want authentication, interpolation/prediction, secure transport (HTTPS/WSS), and scaling (socket clusters or WebRTC-based P2P for lower server bandwidth).
 - To make it public, deploy the server (Heroku/Render/Cloud VM) and update `SERVER_URL` in index.html.

----------
INDEX.HTML (client)
----------
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Lobby — 3D Chat</title>
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
    #overlay{position:absolute;left:12px;top:12px;z-index:10;background:rgba(0,0,0,0.5);color:#fff;padding:12px;border-radius:8px}
    #ui{position:fixed;right:12px;top:12px;z-index:10;width:320px}
    .panel{background:rgba(255,255,255,0.06);color:#fff;padding:10px;border-radius:8px;margin-bottom:8px}
    input,button{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #333;background:rgba(0,0,0,0.6);color:#fff}
    #chatBox{height:220px;overflow:auto;padding:8px;background:rgba(0,0,0,0.35);border-radius:6px}
    #joinUI{min-width:260px}
    #status{font-size:13px;color:#ddd;margin-top:6px}
  </style>
</head>
<body>
  <div id="overlay">Use WASD or arrow keys to move — click the canvas to lock pointer for mouse look.</div>

  <div id="ui">
    <div class="panel" id="joinUI">
      <strong>Join Lobby</strong>
      <input id="nameInput" placeholder="Your name" value="Player" />
      <input id="lobbyInput" placeholder="Lobby name (e.g. lobby1)" value="main" />
      <button id="joinBtn">Join Lobby</button>
      <div id="status">Not connected</div>
    </div>

    <div class="panel" id="chatPanel" style="display:none">
      <div id="chatBox"></div>
      <input id="chatInput" placeholder="Say something... (enter to send)" />
    </div>
  </div>

  <canvas id="c"></canvas>

  <!-- Three.js (r125+ compatible) and socket.io client from CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script>
  // ====== CONFIG ======
  // Change this to your server address (include protocol and port if needed), e.g. http://localhost:3000
  const SERVER_URL = location.origin.replace(https://tbg-ofgg.onrender.com/) ; // default: same origin (useful if hosting server+client together)
  // ====================

  // Basic DOM
  const canvas = document.getElementById('c');
  const chatBox = document.getElementById('chatBox');
  const chatInput = document.getElementById('chatInput');
  const joinBtn = document.getElementById('joinBtn');
  const nameInput = document.getElementById('nameInput');
  const lobbyInput = document.getElementById('lobbyInput');
  const status = document.getElementById('status');
  const chatPanel = document.getElementById('chatPanel');

  // Three.js scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x88aadd);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setSize(innerWidth, innerHeight);

  // lighting
  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  scene.add(light);

  // ground
  const groundGeo = new THREE.PlaneGeometry(100,100);
  const groundMat = new THREE.MeshStandardMaterial({color:0x2a2a2a});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // local player (a 3D block)
  const playerGeo = new THREE.BoxGeometry(1,1,1);
  const playerMat = new THREE.MeshStandardMaterial({color:0x00aa00});
  const localPlayerMesh = new THREE.Mesh(playerGeo, playerMat);
  localPlayerMesh.position.y = 0.5;
  scene.add(localPlayerMesh);

  // other players container
  const others = {}; // id -> {mesh, name}

  // pointer lock controls for mouse look
  const controls = new THREE.PointerLockControls(camera, document.body);
  document.addEventListener('click', () => { controls.lock(); });

  // camera follows player from behind
  camera.position.set(0, 1.6, -3);

  // movement state
  const keys = {w:false,a:false,s:false,d:false,ArrowUp:false,ArrowDown:false,ArrowLeft:false,ArrowRight:false};
  document.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key)) keys[e.key]=true; });
  document.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key)) keys[e.key]=false; });

  // simple player state
  const state = {x:0,y:0.5,z:0,rotY:0};
  const speed = 4; // units per second

  // networking (will be created on join)
  let socket = null;
  let myId = null;

  function connectToServer(name,lobby){
    status.textContent = 'Connecting...';
    socket = io(SERVER_URL, {transports:['websocket']});

    socket.on('connect', () => {
      myId = socket.id;
      status.textContent = 'Connected — joined: ' + lobby;
      chatPanel.style.display = 'block';
      document.getElementById('joinUI').style.display = 'none';
      socket.emit('joinLobby', {name, lobby});
    });

    socket.on('initialPlayers', players => {
      // players is an object of {id:{x,z,rotY,name}}
      for(const id in players){ if(id===myId) continue; addOrUpdateRemote(id, players[id]); }
    });

    socket.on('playerJoined', (id, info) => { addOrUpdateRemote(id, info); appendChat(info.name + ' joined the lobby'); });
    socket.on('playerLeft', (id) => { removeRemote(id); });
    socket.on('playerUpdate', (id, info) => { if(id===myId) return; addOrUpdateRemote(id, info); });
    socket.on('chat', (who,msg) => { appendChat(who + ': ' + msg); });

    socket.on('disconnect', () => { status.textContent = 'Disconnected'; appendChat('Disconnected from server'); });
  }

  function addOrUpdateRemote(id, info){
    let o = others[id];
    if(!o){
      const mat = new THREE.MeshStandardMaterial({color: Math.random()*0xffffff});
      const mesh = new THREE.Mesh(playerGeo, mat);
      mesh.position.set(info.x||0,0.5,info.z||0);
      scene.add(mesh);
      const label = makeLabel(info.name||'Anon');
      o = {mesh, name:info.name||'Anon', label};
      others[id]=o;
    }
    // update position smoothly (no prediction here)
    o.mesh.position.x = info.x;
    o.mesh.position.z = info.z;
    o.mesh.rotation.y = info.rotY;
    updateLabelPosition(o);
  }

  function removeRemote(id){
    const o = others[id];
    if(!o) return;
    scene.remove(o.mesh);
    if(o.label && o.label.parentNode) o.label.parentNode.removeChild(o.label);
    delete others[id];
  }

  // very simple DOM label for names
  function makeLabel(text){
    const d = document.createElement('div');
    d.style.position='absolute'; d.style.color='#fff'; d.style.fontSize='13px'; d.style.padding='2px 6px';
    d.style.background='rgba(0,0,0,0.4)'; d.style.borderRadius='6px'; d.innerText = text;
    document.body.appendChild(d); return d;
  }

  function updateLabelPosition(o){
    if(!o.label) return;
    const pos = o.mesh.position.clone(); pos.y += 1.0;
    pos.project(camera);
    const x = (pos.x * 0.5 + 0.5) * innerWidth;
    const y = ( - pos.y * 0.5 + 0.5) * innerHeight;
    o.label.style.left = Math.round(x) + 'px';
    o.label.style.top  = Math.round(y) + 'px';
  }

  function appendChat(txt){
    const p = document.createElement('div'); p.innerText = txt; chatBox.appendChild(p); chatBox.scrollTop = chatBox.scrollHeight;
  }

  chatInput.addEventListener('keydown', e => {
    if(e.key === 'Enter' && chatInput.value.trim() !== ''){
      const msg = chatInput.value.trim();
      chatInput.value = '';
      appendChat('Me: ' + msg);
      if(socket) socket.emit('chat', msg);
    }
  });

  joinBtn.addEventListener('click', () => {
    const name = nameInput.value.trim() || 'Player';
    const lobby = lobbyInput.value.trim() || 'main';
    connectToServer(name,lobby);
  });

  // send movement updates to server at regular intervals
  let lastSent = 0;
  function sendUpdate(){
    if(!socket) return;
    const info = {x: state.x, z: state.z, rotY: state.rotY, name: nameInput.value};
    socket.emit('playerMove', info);
  }

  // main loop
  let last = performance.now();
  function animate(t){
    const dt = (t - last) / 1000; last = t;

    // simple Euler movement
    let forward = (keys.w || keys.ArrowUp) ? 1 : (keys.s || keys.ArrowDown) ? -1 : 0;
    let strafe = (keys.d || keys.ArrowRight) ? 1 : (keys.a || keys.ArrowLeft) ? -1 : 0;

    // rotate by mouse yaw from controls (PointerLockControls stores rotation in camera)
    const yaw = controls.getObject().rotation.y || 0;
    state.rotY = yaw;

    const sin = Math.sin(yaw), cos = Math.cos(yaw);
    state.x += (cos * forward - sin * strafe) * speed * dt;
    state.z += (sin * forward + cos * strafe) * speed * dt;

    // update local player mesh and camera
    localPlayerMesh.position.set(state.x, 0.5, state.z);

    // position camera relative to player
    const camOffset = new THREE.Vector3(0,1.6,-3).applyAxisAngle(new THREE.Vector3(0,1,0), state.rotY);
    camera.position.copy(localPlayerMesh.position).add(camOffset);
    camera.lookAt(localPlayerMesh.position.x, localPlayerMesh.position.y + 1.0, localPlayerMesh.position.z);

    // update others' labels
    for(const id in others) updateLabelPosition(others[id]);

    renderer.setSize(innerWidth, innerHeight);
    renderer.render(scene, camera);

    // send updates ~12 times per second
    if(performance.now() - lastSent > 80){ sendUpdate(); lastSent = performance.now(); }

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // handle resizing
  window.addEventListener('resize', () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
  </script>



<!--
----------
SERVER.JS (Node.js)
Save as server.js and run: npm install express socket.io
Then: node server.js
This server serves a small API for rooms and relays position/chat events.
----------
-->

<pre style="display:none">
// ===== server.js =====
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

// Serve static client if you want: put your index.html in ./public
app.use(express.static('public'));

const rooms = {}; // roomName -> { players: {socketId: info} }

io.on('connection', socket => {
  console.log('conn', socket.id);

  socket.on('joinLobby', ({name, lobby}) => {
    socket.join(lobby);
    socket.data.name = name || 'Player';
    socket.data.lobby = lobby;

    rooms[lobby] = rooms[lobby] || {players:{}};
    rooms[lobby].players[socket.id] = {x:0,z:0,rotY:0,name:socket.data.name};

    // send initial players to the newly joined client
    socket.emit('initialPlayers', rooms[lobby].players);

    // inform others in room
    socket.to(lobby).emit('playerJoined', socket.id, rooms[lobby].players[socket.id]);
  });

  socket.on('playerMove', info => {
    const lobby = socket.data.lobby;
    if(!lobby) return;
    // save
    rooms[lobby] = rooms[lobby] || {players:{}};
    rooms[lobby].players[socket.id] = {x:info.x, z:info.z, rotY:info.rotY, name:socket.data.name};
    // broadcast to others
    socket.to(lobby).emit('playerUpdate', socket.id, rooms[lobby].players[socket.id]);
  });

  socket.on('chat', msg => {
    const lobby = socket.data.lobby;
    if(!lobby) return;
    io.to(lobby).emit('chat', socket.data.name, msg);
  });

  socket.on('disconnect', () => {
    const lobby = socket.data.lobby;
    if(lobby && rooms[lobby]){
      delete rooms[lobby].players[socket.id];
      socket.to(lobby).emit('playerLeft', socket.id);
    }
    console.log('left', socket.id);
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => console.log('Server listening on', PORT));
// ===== end server.js =====
</pre>

<!--
Instructions (short):
1) Place index.html in a folder. Option A: serve it from the Node server by putting it into ./public/index.html
   - Then set SERVER_URL to the server origin and open the site in browser.
2) Install Node dependencies: npm init -y && npm i express socket.io
3) Run: node server.js
4) Open the page (http://localhost:3000) in multiple browser windows to test multiplayer locally.

Security & production notes:
 - Use HTTPS/WSS in production.
 - Add rate-limiting / validation to messages.
 - Add interpolation on clients for smooth movement.
 - Consider using binary protocols or smaller messages for efficiency.

Have fun! Tweak block size, colors, chat UI, and add emotes, voice, or friend lists.
-->
</body>
</html>

